<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>StrictDB Documentation — Full API Reference</title>
  <meta name="description" content="Complete API reference for StrictDB — unified database driver for MongoDB, PostgreSQL, MySQL, MSSQL, SQLite, and Elasticsearch. Filter translations, SQL dialect guides, AI integration, MCP tools, and real-world examples.">
  <meta name="keywords" content="StrictDB documentation, database API reference, MongoDB to SQL translation, filter operators, SQL dialects, AI database tools, MCP server, schema validation, TypeScript database, query translation">
  <meta name="author" content="TheDecipherist">
  <meta name="robots" content="index, follow">
  <link rel="canonical" href="https://thedecipherist.github.io/strictdb/docs.html">

  <!-- Open Graph -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="StrictDB Documentation — Full API Reference">
  <meta property="og:description" content="Complete API reference for StrictDB — filter translations, SQL dialect guides, AI integration, MCP tools, schema validation, and real-world examples.">
  <meta property="og:url" content="https://thedecipherist.github.io/strictdb/docs.html">
  <meta property="og:image" content="https://thedecipherist.github.io/strictdb/banner.webp">
  <meta property="og:image:width" content="2752">
  <meta property="og:image:height" content="1536">
  <meta property="og:site_name" content="StrictDB">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="StrictDB Documentation — Full API Reference">
  <meta name="twitter:description" content="Complete API reference for StrictDB — filter translations, SQL dialect guides, AI integration, MCP tools, schema validation, and real-world examples.">
  <meta name="twitter:image" content="https://thedecipherist.github.io/strictdb/banner.webp">

  <!-- JSON-LD Structured Data -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "TechArticle",
    "name": "StrictDB Documentation",
    "headline": "StrictDB Documentation — Full API Reference",
    "description": "Complete API reference for StrictDB — unified database driver for MongoDB, PostgreSQL, MySQL, MSSQL, SQLite, and Elasticsearch with AI-first guardrails, self-correcting errors, schema discovery, and MCP server.",
    "url": "https://thedecipherist.github.io/strictdb/docs.html",
    "about": {
      "@type": "SoftwareSourceCode",
      "name": "StrictDB",
      "codeRepository": "https://github.com/TheDecipherist/strictdb",
      "programmingLanguage": "TypeScript"
    },
    "author": {
      "@type": "Person",
      "name": "TheDecipherist",
      "url": "https://github.com/TheDecipherist"
    }
  }
  </script>

  <link rel="icon" type="image/webp" href="logo.webp">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    *,*::before,*::after{margin:0;padding:0;box-sizing:border-box}
    :root{--purple:#a855f7;--pink:#ec4899;--blue:#3b82f6;--cyan:#06b6d4;--emerald:#10b981;--orange:#f97316;--yellow:#eab308;--red:#ef4444;--indigo:#6366f1;--bg:#0a0a0f;--bg-card:#111119;--bg-code:#0d0d14;--text:#e4e4eb;--text-muted:#8888a0;--border:#1e1e2e}
    html{scroll-behavior:smooth}
    body{font-family:'Inter',sans-serif;background:var(--bg);color:var(--text);line-height:1.7;overflow-x:hidden}
    .bg-glow{position:fixed;inset:0;pointer-events:none;z-index:0;overflow:hidden}
    .bg-glow .orb{position:absolute;border-radius:50%;filter:blur(120px);opacity:.12;animation:float 20s ease-in-out infinite}
    .bg-glow .orb:nth-child(1){width:600px;height:600px;background:var(--purple);top:-10%;left:-5%}
    .bg-glow .orb:nth-child(2){width:500px;height:500px;background:var(--cyan);top:40%;right:-10%;animation-delay:-7s}
    .bg-glow .orb:nth-child(3){width:600px;height:600px;background:var(--pink);bottom:-10%;left:40%;animation-delay:-12s}
    @keyframes float{0%,100%{transform:translate(0,0) scale(1)}50%{transform:translate(-20px,20px) scale(.95)}}

    /* NAV */
    nav{position:fixed;top:0;left:0;right:0;z-index:100;background:rgba(10,10,15,.85);backdrop-filter:blur(20px);border-bottom:1px solid var(--border)}
    nav .c{display:flex;align-items:center;justify-content:space-between;height:64px;max-width:1200px;margin:0 auto;padding:0 24px}
    .logo{font-size:1.4rem;font-weight:800;background:linear-gradient(135deg,var(--emerald),var(--cyan),var(--purple),var(--orange));-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;letter-spacing:-0.5px;display:flex;align-items:center;text-decoration:none}
    .logo img{margin-right:10px}
    .nav-links{display:flex;gap:32px;align-items:center}
    .nav-links a{color:var(--text-muted);text-decoration:none;font-size:.9rem;font-weight:500;transition:color .2s}
    .nav-links a:hover{color:var(--text)}
    .nav-links a.active{color:var(--cyan)}
    .nav-cta{background:linear-gradient(135deg,var(--purple),var(--pink))!important;color:#fff!important;padding:8px 20px;border-radius:8px;font-weight:600!important;transition:opacity .2s!important}
    .nav-cta:hover{opacity:.9}
    .mobile-toggle{display:none;background:none;border:none;color:var(--text);font-size:1.5rem;cursor:pointer;padding:4px}

    /* LAYOUT */
    .page{display:grid;grid-template-columns:260px 1fr;max-width:1200px;margin:0 auto;padding-top:64px;min-height:100vh;position:relative;z-index:1}
    .sidebar{position:sticky;top:64px;height:calc(100vh - 64px);overflow-y:auto;padding:32px 16px 32px 24px;border-right:1px solid var(--border)}
    .sidebar::-webkit-scrollbar{width:4px}
    .sidebar::-webkit-scrollbar-thumb{background:var(--border);border-radius:4px}
    .sidebar h4{font-size:.7rem;font-weight:700;text-transform:uppercase;letter-spacing:1.5px;color:var(--text-muted);margin:24px 0 8px}
    .sidebar h4:first-child{margin-top:0}
    .sidebar a{display:block;color:var(--text-muted);text-decoration:none;font-size:.82rem;padding:4px 12px;border-radius:6px;margin:1px 0;transition:all .15s}
    .sidebar a:hover{color:var(--text);background:rgba(255,255,255,.03)}
    .sidebar a.active{color:var(--cyan);background:rgba(6,182,212,.08)}
    .content{padding:40px 48px 120px;max-width:900px;overflow-x:hidden}

    /* HEADINGS */
    .content h1{font-size:2.2rem;font-weight:800;letter-spacing:-1px;margin-bottom:8px;background:linear-gradient(135deg,var(--emerald),var(--cyan),var(--purple));-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
    .content h2{font-size:1.6rem;font-weight:800;letter-spacing:-.5px;margin:56px 0 16px;padding-top:24px;border-top:1px solid var(--border)}
    .content h2:first-of-type{border-top:none;margin-top:32px}
    .content h3{font-size:1.15rem;font-weight:700;margin:32px 0 12px;color:var(--text)}
    .content h4{font-size:.95rem;font-weight:600;margin:20px 0 8px}
    .content>p,.content>ul,.content>ol{margin-bottom:16px;color:var(--text-muted);font-size:.92rem}
    .content ul,.content ol{padding-left:24px}
    .content li{margin-bottom:6px}
    .content a{color:var(--cyan);text-decoration:none}
    .content a:hover{text-decoration:underline}
    .content strong{color:var(--text);font-weight:600}
    .content>hr{border:none;height:1px;background:linear-gradient(90deg,transparent,var(--purple),var(--pink),var(--cyan),transparent);opacity:.3;margin:48px 0}

    /* INLINE CODE */
    code{font-family:'JetBrains Mono',monospace;font-size:.82rem;background:rgba(168,85,247,.08);color:var(--purple);padding:2px 7px;border-radius:4px}
    h2 code,h3 code{font-size:.9em}

    /* CODE BLOCKS */
    pre{background:var(--bg-code);border:1px solid var(--border);border-radius:12px;padding:20px 24px;overflow-x:auto;margin:12px 0 20px;font-family:'JetBrains Mono',monospace;font-size:.8rem;line-height:1.7}
    pre code{background:none;padding:0;color:var(--text)}
    .kw{color:var(--purple)}.fn{color:var(--blue)}.str{color:var(--emerald)}.num{color:var(--orange)}.cm{color:var(--text-muted);font-style:italic}.op{color:var(--pink)}.type{color:var(--cyan)}.prop{color:var(--text)}

    /* TABLES */
    table{width:100%;border-collapse:collapse;margin:12px 0 24px;font-size:.85rem}
    th,td{padding:10px 14px;text-align:left;border-bottom:1px solid var(--border)}
    th{font-weight:700;font-size:.75rem;text-transform:uppercase;letter-spacing:.5px;color:var(--text-muted)}
    td code{font-size:.78rem}

    /* BADGES */
    .badge{display:inline-block;font-size:.65rem;font-weight:700;text-transform:uppercase;letter-spacing:1px;padding:3px 10px;border-radius:5px;margin-left:8px;vertical-align:middle}
    .badge-green{background:rgba(16,185,129,.15);color:var(--emerald)}
    .badge-red{background:rgba(239,68,68,.15);color:var(--red)}
    .badge-yellow{background:rgba(234,179,8,.15);color:var(--yellow)}
    .badge-blue{background:rgba(59,130,246,.15);color:var(--blue)}
    .badge-purple{background:rgba(168,85,247,.15);color:var(--purple)}

    /* CALLOUTS */
    .callout{border-radius:12px;padding:16px 20px;margin:16px 0 24px;font-size:.88rem}
    .callout-info{background:rgba(6,182,212,.06);border:1px solid rgba(6,182,212,.15)}
    .callout-warn{background:rgba(234,179,8,.06);border:1px solid rgba(234,179,8,.15)}
    .callout-danger{background:rgba(239,68,68,.06);border:1px solid rgba(239,68,68,.15)}
    .callout strong{display:block;margin-bottom:4px}

    /* TRANSLATION GRID */
    .trans-grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin:12px 0 24px}
    .trans-grid>div>span{display:block;font-size:.7rem;font-weight:700;text-transform:uppercase;letter-spacing:1px;margin-bottom:6px}
    .trans-grid pre{margin:0}
    .trans-label-mongo{color:var(--emerald)}
    .trans-label-pg{color:var(--blue)}
    .trans-label-mysql{color:var(--orange)}
    .trans-label-mssql{color:var(--red)}
    .trans-label-sqlite{color:var(--cyan)}
    .trans-label-es{color:var(--yellow)}
    .trans-label-sql{color:var(--purple)}

    /* RESPONSIVE */
    @media(max-width:900px){
      .page{grid-template-columns:1fr}
      .sidebar{display:none}
      .content{padding:32px 20px 80px}
    }
    @media(max-width:640px){
      .nav-links{display:none;position:absolute;top:64px;left:0;right:0;flex-direction:column;background:rgba(10,10,15,.95);backdrop-filter:blur(20px);padding:20px 24px;gap:16px;border-bottom:1px solid var(--border)}
      .nav-links.open{display:flex}
      .mobile-toggle{display:block}
    }
  </style>
  <script
    src="https://app.rybbit.io/api/script.js"
    data-site-id="e7e29192d813"
    defer
  ></script>
</head>
<body>
<div class="bg-glow"><div class="orb"></div><div class="orb"></div><div class="orb"></div></div>

<nav><div class="c">
  <a href="index.html" class="logo"><img src="logo.webp" alt="StrictDB logo" width="56" height="56" style="vertical-align:middle;margin-right:10px;">StrictDB</a>
  <button class="mobile-toggle" onclick="document.querySelector('.nav-links').classList.toggle('open')" aria-label="Toggle menu">&#9776;</button>
  <div class="nav-links">
    <a href="index.html#features">Features</a>
    <a href="index.html#ai">AI Tools</a>
    <a href="index.html#guardrails">Guardrails</a>
    <a href="index.html#mcp">MCP</a>
    <a href="index.html#compare">Compare</a>
    <a href="docs.html" class="active">Docs</a>
    <a href="https://github.com/TheDecipherist/strictdb" class="nav-cta">GitHub</a>
  </div>
</div></nav>

<div class="page">
<aside class="sidebar">
  <h4>Getting Started</h4>
  <a href="#install">Installation</a>
  <a href="#quick-start">Quick Start</a>
  <a href="#config">Configuration</a>
  <h4>Core API</h4>
  <a href="#read-ops">Read Operations</a>
  <a href="#write-ops">Write Operations</a>
  <a href="#receipts">Operation Receipts</a>
  <a href="#transactions">Transactions</a>
  <a href="#batch">Batch Operations</a>
  <h4>Filter Reference</h4>
  <a href="#filter-comparison">Comparison Operators</a>
  <a href="#filter-array">Array &amp; Pattern</a>
  <a href="#filter-logical">Logical Operators</a>
  <a href="#filter-translation">SQL Translation</a>
  <a href="#filter-es">ES Translation</a>
  <h4>Update Operators</h4>
  <a href="#update-ops">$set, $inc, $unset</a>
  <a href="#update-array">$push, $pull</a>
  <a href="#update-sql">SQL Translation</a>
  <a href="#update-es">ES Painless Scripts</a>
  <h4>SQL Dialects</h4>
  <a href="#sql-params">Parameter Styles</a>
  <a href="#sql-pagination">Pagination</a>
  <a href="#sql-single-row">Single-Row Semantics</a>
  <a href="#sql-upsert">Upsert</a>
  <a href="#sql-projection">Projection</a>
  <h4>Schema &amp; Validation</h4>
  <a href="#zod-schema">Zod Registration</a>
  <a href="#ddl-gen">SQL DDL Generation</a>
  <a href="#es-mapping">ES Mapping Generation</a>
  <a href="#runtime-validation">Runtime Validation</a>
  <h4>Safety</h4>
  <a href="#guardrails">Guardrails</a>
  <a href="#sanitize">Sanitization</a>
  <a href="#sanitize-rules">Custom Sanitize Rules</a>
  <h4>AI Integration</h4>
  <a href="#ai-overview">Why AI-First?</a>
  <a href="#describe">describe()</a>
  <a href="#validate">validate()</a>
  <a href="#explain">explain()</a>
  <a href="#self-correct">Self-Correcting Errors</a>
  <h4>MCP Server</h4>
  <a href="#mcp-install">Setup</a>
  <a href="#mcp-tools">All 14 Tools</a>
  <a href="#mcp-claude">Claude Desktop Config</a>
  <h4>Events &amp; Lifecycle</h4>
  <a href="#events">Events</a>
  <a href="#reconnect">Reconnection</a>
  <a href="#timestamps">Auto Timestamps</a>
  <a href="#raw">Escape Hatch</a>
  <h4>Reference</h4>
  <a href="#errors">Error Codes</a>
  <a href="#types">TypeScript Types</a>
</aside>

<main class="content">

<h1>StrictDB Documentation</h1>
<p>Complete API reference for <strong>strictdb</strong> and <strong>strictdb-mcp</strong>. One unified API for MongoDB, PostgreSQL, MySQL, MSSQL, SQLite, and Elasticsearch.</p>

<!-- ============================================================ -->
<h2 id="install">Installation</h2>

<p>Install the core package and the peer dependency for your database:</p>
<pre><code><span class="cm"># Core package</span>
npm install strictdb

<span class="cm"># Add your database driver (pick one or more)</span>
npm install mongodb              <span class="cm"># MongoDB</span>
npm install pg                   <span class="cm"># PostgreSQL</span>
npm install mysql2               <span class="cm"># MySQL</span>
npm install mssql                <span class="cm"># MSSQL</span>
npm install better-sqlite3       <span class="cm"># SQLite</span>
npm install @elastic/elasticsearch  <span class="cm"># Elasticsearch</span></code></pre>

<div class="callout callout-info">
  <strong>Zero unused dependencies.</strong> All database drivers are peer dependencies — you only install what you actually use.
</div>

<!-- ============================================================ -->
<h2 id="quick-start">Quick Start</h2>

<p>StrictDB auto-detects your backend from the connection URI. No configuration files, no schema definitions required.</p>
<pre><code><span class="kw">import</span> { <span class="type">StrictDB</span> } <span class="kw">from</span> <span class="str">'strictdb'</span>;

<span class="cm">// Auto-detects backend from URI</span>
<span class="kw">const</span> db = <span class="kw">await</span> <span class="type">StrictDB</span>.<span class="fn">create</span>({
  uri: <span class="str">'postgresql://user:pass@localhost:5432/mydb'</span>
});

<span class="cm">// Read</span>
<span class="kw">const</span> user = <span class="kw">await</span> db.<span class="fn">queryOne</span>(<span class="str">'users'</span>, { email: <span class="str">'alice@example.com'</span> });

<span class="cm">// Write — returns a receipt, never void</span>
<span class="kw">const</span> receipt = <span class="kw">await</span> db.<span class="fn">insertOne</span>(<span class="str">'users'</span>, {
  email: <span class="str">'bob@example.com'</span>,
  name: <span class="str">'Bob'</span>,
  role: <span class="str">'user'</span>
});
console.<span class="fn">log</span>(receipt.insertedCount); <span class="cm">// 1</span>

<span class="cm">// Update with MongoDB-style operators</span>
<span class="kw">await</span> db.<span class="fn">updateOne</span>(<span class="str">'users'</span>,
  { email: <span class="str">'bob@example.com'</span> },
  { <span class="op">$set</span>: { role: <span class="str">'admin'</span> }, <span class="op">$inc</span>: { loginCount: <span class="num">1</span> } }
);

<span class="cm">// Same code works on Mongo, Postgres, MySQL, MSSQL, SQLite, Elasticsearch</span>
<span class="kw">await</span> db.<span class="fn">close</span>();</code></pre>

<h3>URI Auto-Detection</h3>
<table>
  <thead><tr><th>URI Prefix</th><th>Backend</th><th>Driver</th></tr></thead>
  <tbody>
    <tr><td><code>mongodb://</code> / <code>mongodb+srv://</code></td><td>mongo</td><td>mongodb</td></tr>
    <tr><td><code>postgresql://</code> / <code>postgres://</code></td><td>sql</td><td>pg</td></tr>
    <tr><td><code>mysql://</code></td><td>sql</td><td>mysql2</td></tr>
    <tr><td><code>mssql://</code></td><td>sql</td><td>mssql</td></tr>
    <tr><td><code>sqlite:</code> / <code>file:</code></td><td>sql</td><td>better-sqlite3</td></tr>
    <tr><td><code>http://</code> / <code>https://</code></td><td>elastic</td><td>@elastic/elasticsearch</td></tr>
  </tbody>
</table>

<!-- ============================================================ -->
<h2 id="config">Configuration</h2>

<pre><code><span class="kw">const</span> db = <span class="kw">await</span> <span class="type">StrictDB</span>.<span class="fn">create</span>({
  uri: <span class="str">'postgresql://localhost:5432/mydb'</span>,  <span class="cm">// required</span>
  pool: <span class="str">'standard'</span>,        <span class="cm">// 'high' | 'standard' | 'low'</span>
  dbName: <span class="str">'mydb'</span>,           <span class="cm">// override database name</span>
  label: <span class="str">'primary'</span>,          <span class="cm">// logging label</span>
  schema: <span class="num">false</span>,             <span class="cm">// enable Zod validation on writes</span>
  sanitize: <span class="num">true</span>,            <span class="cm">// input sanitization (default: true)</span>
  guardrails: <span class="num">true</span>,          <span class="cm">// dangerous op protection (default: true)</span>
  logging: <span class="num">true</span>,             <span class="cm">// true | false | 'verbose'</span>
  slowQueryMs: <span class="num">1000</span>,         <span class="cm">// slow query threshold in ms</span>
  timestamps: <span class="num">true</span>,          <span class="cm">// auto createdAt/updatedAt injection</span>
  sanitizeRules: [],          <span class="cm">// custom SanitizeRule[] array</span>
  reconnect: {                <span class="cm">// or just true/false</span>
    enabled: <span class="num">true</span>,
    maxAttempts: <span class="num">10</span>,
    initialDelayMs: <span class="num">1000</span>,
    maxDelayMs: <span class="num">30000</span>,
    backoffMultiplier: <span class="num">2</span>
  },
  elastic: {                  <span class="cm">// Elasticsearch-specific options</span>
    apiKey: <span class="str">'...'</span>,
    caFingerprint: <span class="str">'...'</span>,
    sniffOnStart: <span class="num">false</span>
  }
});</code></pre>

<!-- ============================================================ -->
<h2 id="read-ops">Read Operations</h2>

<h3><code>queryOne&lt;T&gt;(collection, filter, options?)</code></h3>
<p>Find a single document matching the filter. Returns <code>null</code> if not found.</p>
<pre><code><span class="kw">const</span> user = <span class="kw">await</span> db.<span class="fn">queryOne</span>&lt;<span class="type">User</span>&gt;(<span class="str">'users'</span>, { email: <span class="str">'alice@example.com'</span> });
<span class="cm">// → User | null</span>

<span class="cm">// With projection — only return specific fields</span>
<span class="kw">const</span> user = <span class="kw">await</span> db.<span class="fn">queryOne</span>(<span class="str">'users'</span>,
  { email: <span class="str">'alice@example.com'</span> },
  { projection: { name: <span class="num">1</span>, email: <span class="num">1</span> } }
);</code></pre>

<h3><code>queryMany&lt;T&gt;(collection, filter, options?)</code></h3>
<p>Find multiple documents. <strong>Limit is required</strong> — guardrails block unbounded queries.</p>
<pre><code><span class="kw">const</span> admins = <span class="kw">await</span> db.<span class="fn">queryMany</span>&lt;<span class="type">User</span>&gt;(<span class="str">'users'</span>, {
  role: <span class="str">'admin'</span>,
  status: { <span class="op">$in</span>: [<span class="str">'active'</span>, <span class="str">'pending'</span>] },
  age: { <span class="op">$gte</span>: <span class="num">18</span> }
}, {
  sort: { createdAt: <span class="num">-1</span> },
  limit: <span class="num">50</span>,
  skip: <span class="num">0</span>
});
<span class="cm">// → User[]</span></code></pre>

<h3><code>queryWithLookup&lt;T&gt;(collection, options)</code></h3>
<p>Join across collections. Uses <code>$lookup</code> on MongoDB, two-query approach on SQL/ES.</p>
<pre><code><span class="kw">const</span> order = <span class="kw">await</span> db.<span class="fn">queryWithLookup</span>&lt;<span class="type">OrderWithUser</span>&gt;(<span class="str">'orders'</span>, {
  match: { orderId: <span class="str">'ORD-001'</span> },
  lookup: {
    from: <span class="str">'users'</span>,          <span class="cm">// related collection</span>
    localField: <span class="str">'userId'</span>,    <span class="cm">// field in orders</span>
    foreignField: <span class="str">'_id'</span>,     <span class="cm">// field in users</span>
    as: <span class="str">'user'</span>,              <span class="cm">// nest result here</span>
    type: <span class="str">'left'</span>             <span class="cm">// 'left' | 'inner'</span>
  },
  sort: { createdAt: <span class="num">-1</span> },
  limit: <span class="num">1</span>
});
<span class="cm">// → { orderId: 'ORD-001', userId: '...', user: { name: 'Alice', ... } }</span></code></pre>

<div class="callout callout-info">
  <strong>How lookups work per backend:</strong> MongoDB uses native <code>$lookup</code> aggregation. SQL backends execute two queries (main + related) and nest the results. Elasticsearch uses the same two-query approach.
</div>

<h3><code>count&lt;T&gt;(collection, filter?)</code></h3>
<pre><code><span class="kw">const</span> total = <span class="kw">await</span> db.<span class="fn">count</span>(<span class="str">'users'</span>, { role: <span class="str">'admin'</span> });
<span class="cm">// → number</span></code></pre>

<h3>QueryOptions</h3>
<table>
  <thead><tr><th>Option</th><th>Type</th><th>Description</th></tr></thead>
  <tbody>
    <tr><td><code>sort</code></td><td><code>{ field: 1 | -1 }</code></td><td>Sort direction. <code>1</code> = ascending, <code>-1</code> = descending</td></tr>
    <tr><td><code>limit</code></td><td><code>number</code></td><td>Max documents to return. <strong>Required for queryMany</strong></td></tr>
    <tr><td><code>skip</code></td><td><code>number</code></td><td>Number of documents to skip (pagination)</td></tr>
    <tr><td><code>projection</code></td><td><code>{ field: 0 | 1 }</code></td><td>Include (1) or exclude (0) fields from results</td></tr>
  </tbody>
</table>

<!-- ============================================================ -->
<h2 id="write-ops">Write Operations</h2>
<p>All write operations return an <code>OperationReceipt</code> — never void.</p>

<h3><code>insertOne&lt;T&gt;(collection, doc)</code></h3>
<pre><code><span class="kw">const</span> receipt = <span class="kw">await</span> db.<span class="fn">insertOne</span>(<span class="str">'users'</span>, {
  email: <span class="str">'alice@example.com'</span>,
  name: <span class="str">'Alice'</span>,
  role: <span class="str">'user'</span>,
  age: <span class="num">28</span>
});
<span class="cm">// receipt.insertedCount === 1</span></code></pre>

<h3><code>insertMany&lt;T&gt;(collection, docs)</code></h3>
<pre><code><span class="kw">const</span> receipt = <span class="kw">await</span> db.<span class="fn">insertMany</span>(<span class="str">'users'</span>, [
  { email: <span class="str">'alice@example.com'</span>, name: <span class="str">'Alice'</span>, role: <span class="str">'user'</span> },
  { email: <span class="str">'bob@example.com'</span>, name: <span class="str">'Bob'</span>, role: <span class="str">'admin'</span> },
]);
<span class="cm">// receipt.insertedCount === 2</span></code></pre>

<h3><code>updateOne&lt;T&gt;(collection, filter, update, upsert?)</code></h3>
<p>Updates a single document. Enforces single-row semantics on all SQL dialects.</p>
<pre><code><span class="kw">await</span> db.<span class="fn">updateOne</span>(<span class="str">'users'</span>,
  { email: <span class="str">'alice@example.com'</span> },
  { <span class="op">$set</span>: { role: <span class="str">'admin'</span> }, <span class="op">$inc</span>: { loginCount: <span class="num">1</span> } }
);

<span class="cm">// Upsert — insert if not found</span>
<span class="kw">await</span> db.<span class="fn">updateOne</span>(<span class="str">'users'</span>,
  { email: <span class="str">'new@example.com'</span> },
  { <span class="op">$set</span>: { name: <span class="str">'New User'</span>, role: <span class="str">'user'</span> } },
  <span class="num">true</span>  <span class="cm">// upsert</span>
);</code></pre>

<h3><code>updateMany&lt;T&gt;(collection, filter, update, options?)</code></h3>
<p>Update all matching documents. <strong>Empty filter is blocked by guardrails.</strong></p>
<pre><code><span class="cm">// Update all inactive users</span>
<span class="kw">await</span> db.<span class="fn">updateMany</span>(<span class="str">'users'</span>,
  { status: <span class="str">'inactive'</span>, lastLogin: { <span class="op">$lt</span>: cutoffDate } },
  { <span class="op">$set</span>: { archived: <span class="num">true</span> } }
);

<span class="cm">// To update ALL documents, you must confirm:</span>
<span class="kw">await</span> db.<span class="fn">updateMany</span>(<span class="str">'users'</span>,
  { _id: { <span class="op">$exists</span>: <span class="num">true</span> } },
  { <span class="op">$set</span>: { migrated: <span class="num">true</span> } },
  { confirm: <span class="str">'UPDATE_ALL'</span> }
);</code></pre>

<h3><code>deleteOne&lt;T&gt;(collection, filter)</code></h3>
<pre><code><span class="kw">await</span> db.<span class="fn">deleteOne</span>(<span class="str">'users'</span>, { email: <span class="str">'old@example.com'</span> });</code></pre>

<h3><code>deleteMany&lt;T&gt;(collection, filter, options?)</code></h3>
<pre><code><span class="cm">// Delete matching documents</span>
<span class="kw">await</span> db.<span class="fn">deleteMany</span>(<span class="str">'logs'</span>, { createdAt: { <span class="op">$lt</span>: thirtyDaysAgo } });

<span class="cm">// Delete ALL requires explicit confirmation</span>
<span class="kw">await</span> db.<span class="fn">deleteMany</span>(<span class="str">'temp_data'</span>,
  { _id: { <span class="op">$exists</span>: <span class="num">true</span> } },
  { confirm: <span class="str">'DELETE_ALL'</span> }
);</code></pre>

<!-- ============================================================ -->
<h2 id="receipts">Operation Receipts</h2>
<p>Every write operation returns a structured receipt:</p>
<pre><code>{
  operation: <span class="str">'insertOne'</span>,     <span class="cm">// operation name</span>
  collection: <span class="str">'users'</span>,        <span class="cm">// target collection/table</span>
  success: <span class="num">true</span>,              <span class="cm">// did it succeed?</span>
  matchedCount: <span class="num">0</span>,            <span class="cm">// documents matched by filter</span>
  modifiedCount: <span class="num">0</span>,           <span class="cm">// documents actually modified</span>
  insertedCount: <span class="num">1</span>,           <span class="cm">// documents inserted</span>
  deletedCount: <span class="num">0</span>,            <span class="cm">// documents deleted</span>
  duration: <span class="num">12</span>,               <span class="cm">// execution time in ms</span>
  backend: <span class="str">'sql'</span>              <span class="cm">// 'mongo' | 'sql' | 'elastic'</span>
}</code></pre>

<!-- ============================================================ -->
<h2 id="transactions">Transactions</h2>
<p>Full transaction support across all backends:</p>
<pre><code><span class="kw">await</span> db.<span class="fn">withTransaction</span>(<span class="kw">async</span> (tx) => {
  <span class="cm">// All operations inside use the same transaction</span>
  <span class="kw">await</span> tx.<span class="fn">insertOne</span>(<span class="str">'orders'</span>, {
    userId: <span class="str">'user-1'</span>,
    item: <span class="str">'widget'</span>,
    qty: <span class="num">5</span>
  });

  <span class="kw">await</span> tx.<span class="fn">updateOne</span>(<span class="str">'inventory'</span>,
    { sku: <span class="str">'W1'</span> },
    { <span class="op">$inc</span>: { stock: <span class="num">-5</span> } }
  );

  <span class="cm">// If anything throws, entire transaction rolls back</span>
});</code></pre>

<table>
  <thead><tr><th>Backend</th><th>Transaction Support</th><th>Notes</th></tr></thead>
  <tbody>
    <tr><td>MongoDB</td><td>Yes</td><td>Requires replica set</td></tr>
    <tr><td>PostgreSQL</td><td>Yes</td><td>BEGIN / COMMIT / ROLLBACK</td></tr>
    <tr><td>MySQL</td><td>Yes</td><td>START TRANSACTION / COMMIT / ROLLBACK</td></tr>
    <tr><td>MSSQL</td><td>Yes</td><td>BEGIN TRANSACTION / COMMIT / ROLLBACK</td></tr>
    <tr><td>SQLite</td><td>Yes</td><td>BEGIN / COMMIT / ROLLBACK</td></tr>
    <tr><td>Elasticsearch</td><td>No</td><td>Throws <code>UNSUPPORTED_OPERATION</code></td></tr>
  </tbody>
</table>

<!-- ============================================================ -->
<h2 id="batch">Batch Operations</h2>
<pre><code><span class="kw">const</span> receipt = <span class="kw">await</span> db.<span class="fn">batch</span>([
  { operation: <span class="str">'insertOne'</span>, collection: <span class="str">'orders'</span>,
    doc: { item: <span class="str">'widget'</span>, qty: <span class="num">5</span>, userId: <span class="str">'u1'</span> } },
  { operation: <span class="str">'updateOne'</span>, collection: <span class="str">'inventory'</span>,
    filter: { sku: <span class="str">'W1'</span> },
    update: { <span class="op">$inc</span>: { stock: <span class="num">-5</span> } } },
  { operation: <span class="str">'deleteOne'</span>, collection: <span class="str">'cart_items'</span>,
    filter: { userId: <span class="str">'u1'</span>, sku: <span class="str">'W1'</span> } }
]);</code></pre>

<hr>

<!-- ============================================================ -->
<h2 id="filter-comparison">Filter Reference — Comparison Operators</h2>
<p>StrictDB uses MongoDB-style filters across all backends. Filters are automatically translated to SQL WHERE clauses or Elasticsearch Query DSL.</p>

<h3><code>$eq</code> — Equality</h3>
<p>Implicit when you pass a value directly. These are identical:</p>
<pre><code>{ role: <span class="str">'admin'</span> }                   <span class="cm">// shorthand</span>
{ role: { <span class="op">$eq</span>: <span class="str">'admin'</span> } }          <span class="cm">// explicit</span></code></pre>
<div class="trans-grid">
  <div><span class="trans-label-sql">PostgreSQL</span><pre><code>"role" = $1        <span class="cm">-- params: ['admin']</span></code></pre></div>
  <div><span class="trans-label-es">Elasticsearch</span><pre><code>{ term: { role: 'admin' } }</code></pre></div>
</div>

<h3><code>$ne</code> — Not Equal</h3>
<pre><code>{ status: { <span class="op">$ne</span>: <span class="str">'banned'</span> } }</code></pre>
<div class="trans-grid">
  <div><span class="trans-label-sql">SQL</span><pre><code>"status" != $1</code></pre></div>
  <div><span class="trans-label-es">Elasticsearch</span><pre><code>{ bool: { must_not: { term: { status: 'banned' } } } }</code></pre></div>
</div>

<h3><code>$gt</code>, <code>$gte</code>, <code>$lt</code>, <code>$lte</code> — Range</h3>
<pre><code>{ age: { <span class="op">$gte</span>: <span class="num">18</span>, <span class="op">$lt</span>: <span class="num">65</span> } }</code></pre>
<div class="trans-grid">
  <div><span class="trans-label-sql">SQL</span><pre><code>"age" >= $1 AND "age" < $2
<span class="cm">-- params: [18, 65]</span></code></pre></div>
  <div><span class="trans-label-es">Elasticsearch</span><pre><code>{ range: { age: { gte: 18, lt: 65 } } }</code></pre></div>
</div>

<h3><code>null</code> — Null Equality</h3>
<pre><code>{ email: <span class="num">null</span> }</code></pre>
<div class="trans-grid">
  <div><span class="trans-label-sql">SQL</span><pre><code>"email" IS NULL</code></pre></div>
  <div><span class="trans-label-es">Elasticsearch</span><pre><code>{ bool: { must_not: { exists: { field: 'email' } } } }</code></pre></div>
</div>

<!-- ============================================================ -->
<h2 id="filter-array">Filter Reference — Array &amp; Pattern Operators</h2>

<h3><code>$in</code> — Match Any Value in Array</h3>
<pre><code>{ role: { <span class="op">$in</span>: [<span class="str">'admin'</span>, <span class="str">'mod'</span>] } }</code></pre>
<div class="trans-grid">
  <div><span class="trans-label-sql">SQL</span><pre><code>"role" IN ($1, $2)
<span class="cm">-- params: ['admin', 'mod']</span></code></pre></div>
  <div><span class="trans-label-es">Elasticsearch</span><pre><code>{ terms: { role: ['admin', 'mod'] } }</code></pre></div>
</div>

<h3><code>$nin</code> — Not In Array</h3>
<pre><code>{ role: { <span class="op">$nin</span>: [<span class="str">'banned'</span>, <span class="str">'suspended'</span>] } }</code></pre>
<div class="trans-grid">
  <div><span class="trans-label-sql">SQL</span><pre><code>"role" NOT IN ($1, $2)</code></pre></div>
  <div><span class="trans-label-es">Elasticsearch</span><pre><code>{ bool: { must_not: { terms: { role: ['banned', 'suspended'] } } } }</code></pre></div>
</div>

<h3><code>$exists</code> — Field Existence</h3>
<pre><code>{ email: { <span class="op">$exists</span>: <span class="num">true</span> } }   <span class="cm">// field IS NOT NULL</span>
{ email: { <span class="op">$exists</span>: <span class="num">false</span> } }  <span class="cm">// field IS NULL</span></code></pre>
<div class="trans-grid">
  <div><span class="trans-label-sql">SQL ($exists: true)</span><pre><code>"email" IS NOT NULL</code></pre></div>
  <div><span class="trans-label-es">ES ($exists: true)</span><pre><code>{ exists: { field: 'email' } }</code></pre></div>
</div>

<h3><code>$regex</code> — Pattern Matching</h3>
<pre><code>{ name: { <span class="op">$regex</span>: <span class="str">'^Tim'</span> } }</code></pre>
<table>
  <thead><tr><th>Dialect</th><th>SQL Output</th></tr></thead>
  <tbody>
    <tr><td>PostgreSQL</td><td><code>"name" ~ $1</code></td></tr>
    <tr><td>MySQL</td><td><code>"name" REGEXP ?</code></td></tr>
    <tr><td>MSSQL</td><td><code>"name" LIKE @p1</code></td></tr>
    <tr><td>SQLite</td><td><code>"name" LIKE ?</code></td></tr>
    <tr><td>Elasticsearch</td><td><code>{ regexp: { name: '^Tim' } }</code></td></tr>
  </tbody>
</table>

<h3><code>$size</code> — Array Length</h3>
<pre><code>{ tags: { <span class="op">$size</span>: <span class="num">3</span> } }</code></pre>
<table>
  <thead><tr><th>Dialect</th><th>Translation</th></tr></thead>
  <tbody>
    <tr><td>PostgreSQL</td><td><code>jsonb_array_length("tags") = $1</code></td></tr>
    <tr><td>MySQL</td><td><code>JSON_LENGTH("tags") = ?</code></td></tr>
    <tr><td>SQLite</td><td><code>json_array_length("tags") = ?</code></td></tr>
    <tr><td>Elasticsearch</td><td>Script query on array length</td></tr>
  </tbody>
</table>

<!-- ============================================================ -->
<h2 id="filter-logical">Filter Reference — Logical Operators</h2>

<h3><code>$and</code> — All Conditions Must Match</h3>
<pre><code>{ <span class="op">$and</span>: [{ age: { <span class="op">$gte</span>: <span class="num">18</span> } }, { role: <span class="str">'admin'</span> }] }</code></pre>
<div class="trans-grid">
  <div><span class="trans-label-sql">SQL</span><pre><code>(("age" >= $1) AND ("role" = $2))</code></pre></div>
  <div><span class="trans-label-es">Elasticsearch</span><pre><code>{ bool: { must: [
  { range: { age: { gte: 18 } } },
  { term: { role: 'admin' } }
] } }</code></pre></div>
</div>

<p>Multiple top-level fields are implicitly <code>$and</code>:</p>
<pre><code>{ role: <span class="str">'admin'</span>, age: { <span class="op">$gte</span>: <span class="num">18</span> } }
<span class="cm">// SQL: "role" = $1 AND "age" >= $2</span></code></pre>

<h3><code>$or</code> — Any Condition Matches</h3>
<pre><code>{ <span class="op">$or</span>: [{ role: <span class="str">'admin'</span> }, { role: <span class="str">'mod'</span> }] }</code></pre>
<div class="trans-grid">
  <div><span class="trans-label-sql">SQL</span><pre><code>(("role" = $1) OR ("role" = $2))</code></pre></div>
  <div><span class="trans-label-es">Elasticsearch</span><pre><code>{ bool: { should: [
  { term: { role: 'admin' } },
  { term: { role: 'mod' } }
], minimum_should_match: 1 } }</code></pre></div>
</div>

<h3><code>$nor</code> — No Conditions Match</h3>
<pre><code>{ <span class="op">$nor</span>: [{ role: <span class="str">'banned'</span> }, { status: <span class="str">'inactive'</span> }] }</code></pre>
<div class="trans-grid">
  <div><span class="trans-label-sql">SQL</span><pre><code>NOT (("role" = $1) OR ("status" = $2))</code></pre></div>
  <div><span class="trans-label-es">Elasticsearch</span><pre><code>{ bool: { must_not: [
  { term: { role: 'banned' } },
  { term: { status: 'inactive' } }
] } }</code></pre></div>
</div>

<h3><code>$not</code> — Negate a Condition</h3>
<pre><code>{ age: { <span class="op">$not</span>: { <span class="op">$gt</span>: <span class="num">18</span> } } }</code></pre>
<div class="trans-grid">
  <div><span class="trans-label-sql">SQL</span><pre><code>NOT ("age" > $1)</code></pre></div>
  <div><span class="trans-label-es">Elasticsearch</span><pre><code>{ bool: { must_not: [
  { range: { age: { gt: 18 } } }
] } }</code></pre></div>
</div>

<!-- ============================================================ -->
<h2 id="filter-translation">Full SQL Translation Examples</h2>
<p>Complete before/after examples showing how MongoDB-style filters become native SQL across all four dialects.</p>

<h3>Real-World Query: Active Admin Users</h3>
<pre><code><span class="cm">// StrictDB filter (works on any backend)</span>
<span class="kw">const</span> filter = {
  status: <span class="str">'active'</span>,
  age: { <span class="op">$gte</span>: <span class="num">18</span> },
  role: { <span class="op">$in</span>: [<span class="str">'admin'</span>, <span class="str">'mod'</span>] }
};</code></pre>
<table>
  <thead><tr><th>Dialect</th><th>Generated SQL</th></tr></thead>
  <tbody>
    <tr><td>PostgreSQL</td><td><code>WHERE "status" = $1 AND "age" >= $2 AND "role" IN ($3, $4)</code></td></tr>
    <tr><td>MySQL</td><td><code>WHERE "status" = ? AND "age" >= ? AND "role" IN (?, ?)</code></td></tr>
    <tr><td>MSSQL</td><td><code>WHERE "status" = @p1 AND "age" >= @p2 AND "role" IN (@p3, @p4)</code></td></tr>
    <tr><td>SQLite</td><td><code>WHERE "status" = ? AND "age" >= ? AND "role" IN (?, ?)</code></td></tr>
  </tbody>
</table>

<h3>Complex Nested Query</h3>
<pre><code>{
  <span class="op">$or</span>: [
    { role: <span class="str">'admin'</span> },
    { <span class="op">$and</span>: [
      { age: { <span class="op">$gte</span>: <span class="num">18</span> } },
      { status: { <span class="op">$ne</span>: <span class="str">'banned'</span> } },
      { email: { <span class="op">$exists</span>: <span class="num">true</span> } }
    ]}
  ]
}</code></pre>
<pre><code><span class="cm">-- PostgreSQL output:</span>
(("role" = $1) OR (("age" >= $2) AND ("status" != $3) AND ("email" IS NOT NULL)))</code></pre>

<h3>Full SELECT Statements</h3>
<table>
  <thead><tr><th>Operation</th><th>SQL Output (PostgreSQL)</th></tr></thead>
  <tbody>
    <tr><td>Basic select</td><td><code>SELECT * FROM "users" WHERE "role" = $1</code></td></tr>
    <tr><td>With sort + limit</td><td><code>SELECT * FROM "users" ORDER BY "name" ASC LIMIT 50</code></td></tr>
    <tr><td>With pagination</td><td><code>SELECT * FROM "users" LIMIT 10 OFFSET 20</code></td></tr>
    <tr><td>Insert</td><td><code>INSERT INTO "users" ("name", "age") VALUES ($1, $2)</code></td></tr>
    <tr><td>Update</td><td><code>UPDATE "users" SET "name" = $1 WHERE "id" = $2</code></td></tr>
    <tr><td>Delete</td><td><code>DELETE FROM "users" WHERE "id" = $1</code></td></tr>
    <tr><td>Count</td><td><code>SELECT COUNT(*) as count FROM "users" WHERE "role" = $1</code></td></tr>
  </tbody>
</table>

<!-- ============================================================ -->
<h2 id="filter-es">Elasticsearch Translation Examples</h2>

<h3>Complex Query to ES Query DSL</h3>
<pre><code><span class="cm">// StrictDB filter</span>
{
  status: <span class="str">'active'</span>,
  age: { <span class="op">$gte</span>: <span class="num">18</span>, <span class="op">$lt</span>: <span class="num">65</span> },
  role: { <span class="op">$in</span>: [<span class="str">'admin'</span>, <span class="str">'mod'</span>] },
  email: { <span class="op">$exists</span>: <span class="num">true</span> }
}

<span class="cm">// Elasticsearch Query DSL output:</span>
{
  bool: {
    must: [
      { term: { status: <span class="str">'active'</span> } },
      { range: { age: { gte: <span class="num">18</span>, lt: <span class="num">65</span> } } },
      { terms: { role: [<span class="str">'admin'</span>, <span class="str">'mod'</span>] } },
      { exists: { field: <span class="str">'email'</span> } }
    ]
  }
}</code></pre>

<hr>

<!-- ============================================================ -->
<h2 id="update-ops">Update Operators — $set, $inc, $unset</h2>

<h3><code>$set</code> — Set Field Values</h3>
<pre><code>{ <span class="op">$set</span>: { name: <span class="str">'Bob'</span>, role: <span class="str">'admin'</span> } }</code></pre>
<div class="trans-grid">
  <div><span class="trans-label-sql">SQL</span><pre><code>SET "name" = $1, "role" = $2</code></pre></div>
  <div><span class="trans-label-es">ES Painless</span><pre><code>ctx._source.name = params.set_name;
ctx._source.role = params.set_role</code></pre></div>
</div>

<h3><code>$inc</code> — Increment Numeric Fields</h3>
<pre><code>{ <span class="op">$inc</span>: { loginCount: <span class="num">1</span>, score: <span class="num">-5</span> } }</code></pre>
<div class="trans-grid">
  <div><span class="trans-label-sql">SQL</span><pre><code>SET "loginCount" = "loginCount" + $1,
    "score" = "score" + $2</code></pre></div>
  <div><span class="trans-label-es">ES Painless</span><pre><code>ctx._source.loginCount += params.inc_loginCount;
ctx._source.score += params.inc_score</code></pre></div>
</div>

<h3><code>$unset</code> — Remove Fields</h3>
<pre><code>{ <span class="op">$unset</span>: { tempField: <span class="num">true</span> } }</code></pre>
<div class="trans-grid">
  <div><span class="trans-label-sql">SQL</span><pre><code>SET "tempField" = NULL</code></pre></div>
  <div><span class="trans-label-es">ES Painless</span><pre><code>ctx._source.remove('tempField')</code></pre></div>
</div>

<h3>Combined Update</h3>
<pre><code>{ <span class="op">$set</span>: { name: <span class="str">'Bob'</span> }, <span class="op">$inc</span>: { count: <span class="num">1</span> } }
<span class="cm">// SQL: SET "name" = $1, "count" = "count" + $2</span>
<span class="cm">// ES:  ctx._source.name = params.set_name; ctx._source.count += params.inc_count</span></code></pre>

<!-- ============================================================ -->
<h2 id="update-array">Update Operators — $push, $pull</h2>

<h3><code>$push</code> — Append to Array</h3>
<pre><code>{ <span class="op">$push</span>: { tags: <span class="str">'new-tag'</span> } }</code></pre>
<table>
  <thead><tr><th>Backend</th><th>Behavior</th></tr></thead>
  <tbody>
    <tr><td>MongoDB</td><td>Native <code>$push</code></td></tr>
    <tr><td>Elasticsearch</td><td><code>ctx._source.tags.add(params.push_tags)</code></td></tr>
    <tr><td>SQL</td><td>JSON array manipulation (backend-specific)</td></tr>
  </tbody>
</table>

<h3><code>$pull</code> — Remove from Array</h3>
<pre><code>{ <span class="op">$pull</span>: { tags: <span class="str">'old-tag'</span> } }</code></pre>
<table>
  <thead><tr><th>Backend</th><th>Behavior</th></tr></thead>
  <tbody>
    <tr><td>MongoDB</td><td>Native <code>$pull</code></td></tr>
    <tr><td>Elasticsearch</td><td><code>ctx._source.tags.removeIf(e -> e == params.pull_tags)</code></td></tr>
    <tr><td>SQL</td><td>JSON array manipulation (backend-specific)</td></tr>
  </tbody>
</table>

<hr>

<!-- ============================================================ -->
<h2 id="sql-params">SQL Dialects — Parameter Styles</h2>
<table>
  <thead><tr><th>Dialect</th><th>Placeholder</th><th>Example</th></tr></thead>
  <tbody>
    <tr><td>PostgreSQL</td><td><code>$1, $2, $3...</code></td><td><code>WHERE "age" = $1 AND "role" = $2</code></td></tr>
    <tr><td>MySQL</td><td><code>?, ?, ?...</code></td><td><code>WHERE "age" = ? AND "role" = ?</code></td></tr>
    <tr><td>SQLite</td><td><code>?, ?, ?...</code></td><td><code>WHERE "age" = ? AND "role" = ?</code></td></tr>
    <tr><td>MSSQL</td><td><code>@p1, @p2, @p3...</code></td><td><code>WHERE "age" = @p1 AND "role" = @p2</code></td></tr>
  </tbody>
</table>

<!-- ============================================================ -->
<h2 id="sql-pagination">SQL Dialects — Pagination</h2>
<p>Each SQL dialect handles LIMIT/OFFSET differently. StrictDB generates the correct syntax automatically.</p>
<table>
  <thead><tr><th>Scenario</th><th>PG / MySQL / SQLite</th><th>MSSQL</th></tr></thead>
  <tbody>
    <tr><td>Limit only</td><td><code>LIMIT 10</code></td><td><code>SELECT TOP(10) *</code></td></tr>
    <tr><td>Skip + Limit</td><td><code>LIMIT 10 OFFSET 20</code></td><td><code>ORDER BY (SELECT NULL) OFFSET 20 ROWS FETCH NEXT 10 ROWS ONLY</code></td></tr>
    <tr><td>Skip only</td><td><code>OFFSET 20</code></td><td><code>ORDER BY (SELECT NULL) OFFSET 20 ROWS</code></td></tr>
    <tr><td>Sort + Skip + Limit</td><td><code>ORDER BY "name" ASC LIMIT 10 OFFSET 5</code></td><td><code>ORDER BY "name" ASC OFFSET 5 ROWS FETCH NEXT 10 ROWS ONLY</code></td></tr>
  </tbody>
</table>
<div class="callout callout-info">
  <strong>MSSQL requires ORDER BY for OFFSET.</strong> When no sort is specified, StrictDB automatically inserts <code>ORDER BY (SELECT NULL)</code> as a fallback.
</div>

<!-- ============================================================ -->
<h2 id="sql-single-row">SQL Dialects — Single-Row Semantics</h2>
<p><code>updateOne</code> and <code>deleteOne</code> enforce exactly one row across all dialects:</p>
<table>
  <thead><tr><th>Dialect</th><th>updateOne Technique</th><th>deleteOne Technique</th></tr></thead>
  <tbody>
    <tr><td>PostgreSQL</td><td>Subquery with <code>ctid</code></td><td>Subquery with <code>ctid</code></td></tr>
    <tr><td>MySQL</td><td><code>LIMIT 1</code></td><td><code>LIMIT 1</code></td></tr>
    <tr><td>SQLite</td><td>Subquery with <code>rowid</code></td><td><code>LIMIT 1</code></td></tr>
    <tr><td>MSSQL</td><td><code>UPDATE TOP(1)</code></td><td><code>DELETE TOP(1)</code></td></tr>
  </tbody>
</table>

<!-- ============================================================ -->
<h2 id="sql-upsert">SQL Dialects — Upsert</h2>
<p>Pass <code>upsert: true</code> to <code>updateOne</code>. StrictDB uses an UPDATE-then-INSERT pattern that works identically across all SQL dialects:</p>
<ol>
  <li>Try <code>UPDATE</code> (limited to 1 row)</li>
  <li>If zero rows matched, <code>INSERT</code> with filter equality fields merged with <code>$set</code> fields</li>
</ol>
<pre><code><span class="kw">await</span> db.<span class="fn">updateOne</span>(<span class="str">'users'</span>,
  { email: <span class="str">'test@test.com'</span> },                     <span class="cm">// filter</span>
  { <span class="op">$set</span>: { name: <span class="str">'Test'</span>, role: <span class="str">'user'</span> } },       <span class="cm">// update</span>
  <span class="num">true</span>                                              <span class="cm">// upsert</span>
);
<span class="cm">// If no match → INSERT INTO "users" ("email", "name", "role") VALUES ($1, $2, $3)</span></code></pre>

<!-- ============================================================ -->
<h2 id="sql-projection">SQL Dialects — Projection</h2>
<p><strong>Inclusion</strong> (select specific columns):</p>
<pre><code>{ projection: { name: <span class="num">1</span>, email: <span class="num">1</span> } }
<span class="cm">// → SELECT "name", "email" FROM "users" ...</span></code></pre>
<p><strong>Exclusion</strong> (hide columns — SQL doesn't natively support this, so StrictDB uses post-processing):</p>
<pre><code>{ projection: { password: <span class="num">0</span>, secret: <span class="num">0</span> } }
<span class="cm">// → SELECT * FROM "users" ...  (then strips password, secret from results)</span></code></pre>

<hr>

<!-- ============================================================ -->
<h2 id="zod-schema">Schema &amp; Validation — Zod Registration</h2>
<pre><code><span class="kw">import</span> { z } <span class="kw">from</span> <span class="str">'zod'</span>;

<span class="kw">const</span> userSchema = z.<span class="fn">object</span>({
  email: z.<span class="fn">string</span>().<span class="fn">max</span>(<span class="num">255</span>),
  name: z.<span class="fn">string</span>(),
  age: z.<span class="fn">number</span>().<span class="fn">int</span>().<span class="fn">optional</span>(),
  role: z.<span class="fn">enum</span>([<span class="str">'admin'</span>, <span class="str">'user'</span>, <span class="str">'mod'</span>]),
  active: z.<span class="fn">boolean</span>(),
  createdAt: z.<span class="fn">date</span>(),
  tags: z.<span class="fn">array</span>(z.<span class="fn">string</span>()).<span class="fn">optional</span>(),
  metadata: z.<span class="fn">object</span>({}).<span class="fn">optional</span>(),
});

db.<span class="fn">registerCollection</span>({ name: <span class="str">'users'</span>, schema: userSchema });

<span class="cm">// Auto-create tables/indexes</span>
<span class="kw">await</span> db.<span class="fn">ensureCollections</span>();
<span class="kw">await</span> db.<span class="fn">ensureIndexes</span>();</code></pre>

<!-- ============================================================ -->
<h2 id="ddl-gen">Schema — SQL DDL Generation</h2>
<p>StrictDB introspects Zod schemas and generates <code>CREATE TABLE</code> statements for each dialect:</p>

<h3>PostgreSQL</h3>
<pre><code>CREATE TABLE IF NOT EXISTS "users" (
  "email" VARCHAR(255) NOT NULL,
  "name" TEXT NOT NULL,
  "age" INTEGER,
  "role" TEXT NOT NULL CHECK(role IN ('admin', 'user', 'mod')),
  "active" BOOLEAN NOT NULL,
  "createdAt" TIMESTAMPTZ NOT NULL,
  "tags" JSONB,
  "metadata" JSONB
)</code></pre>

<h3>Type Mapping</h3>
<table>
  <thead><tr><th>Zod Type</th><th>PG</th><th>MySQL</th><th>MSSQL</th><th>SQLite</th></tr></thead>
  <tbody>
    <tr><td><code>z.string().max(N)</code></td><td>VARCHAR(N)</td><td>VARCHAR(N)</td><td>NVARCHAR(N)</td><td>TEXT</td></tr>
    <tr><td><code>z.string()</code></td><td>TEXT</td><td>TEXT</td><td>NVARCHAR(MAX)</td><td>TEXT</td></tr>
    <tr><td><code>z.number().int()</code></td><td>INTEGER</td><td>INT</td><td>INT</td><td>INTEGER</td></tr>
    <tr><td><code>z.number()</code></td><td>DOUBLE PRECISION</td><td>DOUBLE</td><td>FLOAT</td><td>REAL</td></tr>
    <tr><td><code>z.boolean()</code></td><td>BOOLEAN</td><td>TINYINT(1)</td><td>BIT</td><td>INTEGER</td></tr>
    <tr><td><code>z.date()</code></td><td>TIMESTAMPTZ</td><td>DATETIME</td><td>DATETIME2</td><td>TEXT</td></tr>
    <tr><td><code>z.enum([...])</code></td><td>TEXT + CHECK</td><td>TEXT</td><td>NVARCHAR(255)</td><td>TEXT</td></tr>
    <tr><td><code>z.array(...)</code></td><td>JSONB</td><td>JSON</td><td>NVARCHAR(MAX)</td><td>TEXT</td></tr>
  </tbody>
</table>

<!-- ============================================================ -->
<h2 id="es-mapping">Schema — Elasticsearch Mapping Generation</h2>
<table>
  <thead><tr><th>Zod Type</th><th>ES Mapping</th></tr></thead>
  <tbody>
    <tr><td><code>z.string().max(256)</code></td><td><code>{ type: 'keyword' }</code></td></tr>
    <tr><td><code>z.string()</code></td><td><code>{ type: 'text', fields: { keyword: { type: 'keyword', ignore_above: 256 } } }</code></td></tr>
    <tr><td><code>z.number().int()</code></td><td><code>{ type: 'integer' }</code></td></tr>
    <tr><td><code>z.number()</code></td><td><code>{ type: 'double' }</code></td></tr>
    <tr><td><code>z.boolean()</code></td><td><code>{ type: 'boolean' }</code></td></tr>
    <tr><td><code>z.date()</code></td><td><code>{ type: 'date' }</code></td></tr>
    <tr><td><code>z.enum([...])</code></td><td><code>{ type: 'keyword' }</code></td></tr>
    <tr><td><code>z.array(...)</code></td><td><code>{ type: 'nested' }</code></td></tr>
  </tbody>
</table>

<!-- ============================================================ -->
<h2 id="runtime-validation">Schema — Runtime Validation</h2>
<p>With <code>schema: true</code> in config, all writes are validated before execution:</p>
<pre><code><span class="kw">const</span> db = <span class="kw">await</span> <span class="type">StrictDB</span>.<span class="fn">create</span>({ uri, schema: <span class="num">true</span> });

<span class="kw">try</span> {
  <span class="kw">await</span> db.<span class="fn">insertOne</span>(<span class="str">'users'</span>, { name: <span class="str">''</span>, email: <span class="str">'bad'</span> });
} <span class="kw">catch</span> (err) {
  err.code  <span class="cm">// 'VALIDATION_ERROR'</span>
  err.fix   <span class="cm">// "Field 'name' must be at least 1 character. Field 'email' must be a valid email."</span>
}</code></pre>

<hr>

<!-- ============================================================ -->
<h2 id="guardrails">Guardrails</h2>
<p>Enabled by default. These are <strong>hard blocks</strong>, not warnings.</p>
<table>
  <thead><tr><th>Operation</th><th>Blocked When</th><th>Override</th></tr></thead>
  <tbody>
    <tr><td><code>deleteMany({})</code></td><td>Empty filter</td><td><code>{ confirm: 'DELETE_ALL' }</code> + non-empty filter</td></tr>
    <tr><td><code>updateMany({})</code></td><td>Empty filter</td><td><code>{ confirm: 'UPDATE_ALL' }</code> + non-empty filter</td></tr>
    <tr><td><code>deleteOne({})</code></td><td>Empty filter</td><td>Always requires a non-empty filter</td></tr>
    <tr><td><code>queryMany()</code></td><td>No limit specified</td><td>Always include <code>{ limit: N }</code></td></tr>
  </tbody>
</table>
<p>Error code: <code>GUARDRAIL_BLOCKED</code>. Emits <code>guardrail-blocked</code> event.</p>

<!-- ============================================================ -->
<h2 id="sanitize">Sanitization</h2>
<p>Enabled by default. Prevents injection and validates field names.</p>
<ul>
  <li><strong>SQL:</strong> Column names validated against registered schema whitelist</li>
  <li><strong>Elasticsearch:</strong> Internal fields (<code>_id</code>, <code>_source</code>, <code>_score</code>, <code>_index</code>, <code>_type</code>, <code>_routing</code>, <code>_meta</code>, <code>_field_names</code>, <code>_ignored</code>, <code>_seq_no</code>, <code>_primary_term</code>) blocked from user queries</li>
  <li><strong>ES index names:</strong> Wildcards, commas, spaces, system indices (<code>.</code> or <code>-</code> prefix) blocked</li>
  <li><strong>Regex:</strong> Patterns validated for catastrophic backtracking (ReDoS). Nested quantifiers and patterns &gt;1000 chars rejected</li>
</ul>

<!-- ============================================================ -->
<h2 id="sanitize-rules">Custom Sanitize Rules</h2>
<pre><code><span class="kw">const</span> db = <span class="kw">await</span> <span class="type">StrictDB</span>.<span class="fn">create</span>({
  uri,
  sanitizeRules: [
    <span class="cm">// Trim all string fields</span>
    { transform: (v) => <span class="kw">typeof</span> v === <span class="str">'string'</span> ? v.<span class="fn">trim</span>() : v },

    <span class="cm">// Lowercase emails</span>
    { field: <span class="str">'email'</span>, transform: (v) => v.<span class="fn">toLowerCase</span>() },

    <span class="cm">// Strip HTML from specific fields</span>
    { field: [<span class="str">'name'</span>, <span class="str">'bio'</span>],
      transform: (v) => v.<span class="fn">replace</span>(/<[^>]*>/g, <span class="str">''</span>) },

    <span class="cm">// Apply to ALL string fields</span>
    { field: <span class="str">'*'</span>,
      transform: (v) => <span class="kw">typeof</span> v === <span class="str">'string'</span> ? v.<span class="fn">trim</span>() : v },
  ]
});</code></pre>

<h3>SanitizeRule Interface</h3>
<table>
  <thead><tr><th>Property</th><th>Type</th><th>Description</th></tr></thead>
  <tbody>
    <tr><td><code>field</code></td><td><code>string | string[] | '*'</code></td><td>Which fields to apply to. Omit or <code>'*'</code> for all fields.</td></tr>
    <tr><td><code>transform</code></td><td><code>(value, field, collection) => value</code></td><td>Transform function. Receives value, field name, and collection name.</td></tr>
  </tbody>
</table>
<div class="callout callout-info">
  <strong>Rules never mutate input.</strong> A new object is always returned. Rules are applied in order, and missing fields are skipped.
</div>

<hr>

<!-- ============================================================ -->
<h2 id="ai-overview">AI Integration — Why AI-First?</h2>
<p>Traditional database drivers give AI agents raw access with no guardrails. StrictDB provides four tools that make AI database interactions safe and self-correcting:</p>

<table>
  <thead><tr><th>Problem</th><th>Without StrictDB</th><th>With StrictDB</th></tr></thead>
  <tbody>
    <tr><td>AI hallucinates column names</td><td>Query fails with cryptic error</td><td><code>describe()</code> returns real schema</td></tr>
    <tr><td>AI writes bad query</td><td>Executes and corrupts data</td><td><code>validate()</code> catches before execution</td></tr>
    <tr><td>AI doesn't understand translation</td><td>No visibility into native query</td><td><code>explain()</code> shows exact SQL/ES</td></tr>
    <tr><td>AI gets an error</td><td>Parses stack trace (unreliable)</td><td>Reads <code>.fix</code> field (exact action)</td></tr>
    <tr><td>AI runs <code>DELETE FROM users</code></td><td>All data deleted</td><td>Blocked by guardrails</td></tr>
  </tbody>
</table>

<!-- ============================================================ -->
<h2 id="describe"><code>describe(collection)</code> — Schema Discovery</h2>
<pre><code><span class="kw">const</span> schema = <span class="kw">await</span> db.<span class="fn">describe</span>(<span class="str">'users'</span>);
<span class="cm">// {</span>
<span class="cm">//   name: 'users',</span>
<span class="cm">//   backend: 'sql',</span>
<span class="cm">//   fields: [</span>
<span class="cm">//     { name: 'id', type: 'integer', required: true },</span>
<span class="cm">//     { name: 'email', type: 'string', required: true },</span>
<span class="cm">//     { name: 'role', type: 'string', required: true, enum: ['admin', 'user', 'mod'] },</span>
<span class="cm">//     { name: 'age', type: 'integer', required: false },</span>
<span class="cm">//   ],</span>
<span class="cm">//   indexes: [{ fields: { email: 1 }, unique: true }],</span>
<span class="cm">//   documentCount: 12847,</span>
<span class="cm">//   exampleFilter: { role: 'admin' }</span>
<span class="cm">// }</span></code></pre>

<h2 id="validate"><code>validate(collection, operation)</code> — Dry-Run</h2>
<pre><code><span class="kw">const</span> check = <span class="kw">await</span> db.<span class="fn">validate</span>(<span class="str">'users'</span>, {
  filter: { rol: <span class="str">'admin'</span> },              <span class="cm">// typo!</span>
  doc: { email: <span class="str">'test@test.com'</span> }
});
<span class="cm">// { valid: false, errors: [</span>
<span class="cm">//   { field: 'rol', message: 'Unknown field', expected: 'role' }</span>
<span class="cm">// ]}</span></code></pre>

<h2 id="explain"><code>explain(collection, operation)</code> — Query Translation</h2>
<pre><code><span class="kw">const</span> plan = <span class="kw">await</span> db.<span class="fn">explain</span>(<span class="str">'users'</span>, {
  filter: { role: <span class="str">'admin'</span>, age: { <span class="op">$gte</span>: <span class="num">18</span> } },
  sort: { createdAt: <span class="num">-1</span> },
  limit: <span class="num">50</span>
});
<span class="cm">// {</span>
<span class="cm">//   backend: 'sql',</span>
<span class="cm">//   native: 'SELECT * FROM "users" WHERE "role" = $1 AND "age" >= $2 ORDER BY "createdAt" DESC LIMIT 50'</span>
<span class="cm">// }</span></code></pre>

<!-- ============================================================ -->
<h2 id="self-correct">Self-Correcting Errors</h2>
<p>Every <code>StrictDBError</code> includes a <code>.fix</code> field — a plain-English corrective action:</p>
<pre><code><span class="kw">try</span> {
  <span class="kw">await</span> db.<span class="fn">insertOne</span>(<span class="str">'users'</span>, { email: <span class="str">'alice@example.com'</span> });
} <span class="kw">catch</span> (err) {
  err.code       <span class="cm">// 'DUPLICATE_KEY'</span>
  err.fix        <span class="cm">// 'Use updateOne() instead or check with queryOne() first'</span>
  err.retryable  <span class="cm">// false</span>
  err.backend    <span class="cm">// 'sql'</span>
  err.collection <span class="cm">// 'users'</span>
  err.operation  <span class="cm">// 'insertOne'</span>
}</code></pre>

<h3>Fuzzy Collection Matching</h3>
<pre><code><span class="kw">await</span> db.<span class="fn">queryOne</span>(<span class="str">'usres'</span>, { id: <span class="num">1</span> });  <span class="cm">// typo!</span>
<span class="cm">// Error fix: 'Did you mean "users"? Registered collections: users, orders, products'</span></code></pre>

<h3>Method Suggestions</h3>
<pre><code><span class="cm">// If an AI tries to use MongoDB-native method names:</span>
db.find(...)       <span class="cm">// → fix: 'Use queryMany() instead'</span>
db.findOne(...)    <span class="cm">// → fix: 'Use queryOne() instead'</span>
db.bulkWrite(...)  <span class="cm">// → fix: 'Use batch() instead'</span></code></pre>

<hr>

<!-- ============================================================ -->
<h2 id="mcp-install">MCP Server — Setup</h2>
<pre><code><span class="cm"># Install</span>
npm install -g strictdb-mcp

<span class="cm"># Run (reads STRICTDB_URI from environment)</span>
STRICTDB_URI=<span class="str">"postgresql://user:pass@localhost:5432/mydb"</span> npx strictdb-mcp</code></pre>

<!-- ============================================================ -->
<h2 id="mcp-tools">MCP Server — All 14 Tools</h2>
<table>
  <thead><tr><th>Tool</th><th>Type</th><th>Parameters</th></tr></thead>
  <tbody>
    <tr><td><code>strictdb_describe</code></td><td><span class="badge badge-purple">discover</span></td><td><code>collection</code></td></tr>
    <tr><td><code>strictdb_validate</code></td><td><span class="badge badge-purple">validate</span></td><td><code>collection, filter?, update?, doc?</code></td></tr>
    <tr><td><code>strictdb_explain</code></td><td><span class="badge badge-purple">explain</span></td><td><code>collection, filter?, sort?, limit?</code></td></tr>
    <tr><td><code>strictdb_query_one</code></td><td><span class="badge badge-green">read</span></td><td><code>collection, filter, sort?</code></td></tr>
    <tr><td><code>strictdb_query_many</code></td><td><span class="badge badge-green">read</span></td><td><code>collection, filter, sort?, limit (required), skip?</code></td></tr>
    <tr><td><code>strictdb_count</code></td><td><span class="badge badge-green">read</span></td><td><code>collection, filter?</code></td></tr>
    <tr><td><code>strictdb_insert_one</code></td><td><span class="badge badge-yellow">write</span></td><td><code>collection, doc</code></td></tr>
    <tr><td><code>strictdb_insert_many</code></td><td><span class="badge badge-yellow">write</span></td><td><code>collection, docs[]</code></td></tr>
    <tr><td><code>strictdb_update_one</code></td><td><span class="badge badge-yellow">write</span></td><td><code>collection, filter, update {$set?, $inc?, $unset?}, upsert?</code></td></tr>
    <tr><td><code>strictdb_update_many</code></td><td><span class="badge badge-yellow">write</span></td><td><code>collection, filter, update {$set?, $inc?, $unset?}</code></td></tr>
    <tr><td><code>strictdb_delete_one</code></td><td><span class="badge badge-yellow">write</span></td><td><code>collection, filter</code></td></tr>
    <tr><td><code>strictdb_delete_many</code></td><td><span class="badge badge-yellow">write</span></td><td><code>collection, filter</code></td></tr>
    <tr><td><code>strictdb_batch</code></td><td><span class="badge badge-yellow">batch</span></td><td><code>operations[]</code></td></tr>
    <tr><td><code>strictdb_status</code></td><td><span class="badge badge-blue">util</span></td><td><em>none</em></td></tr>
  </tbody>
</table>

<!-- ============================================================ -->
<h2 id="mcp-claude">MCP Server — Claude Desktop Configuration</h2>
<pre><code>{
  <span class="str">"mcpServers"</span>: {
    <span class="str">"strictdb"</span>: {
      <span class="str">"command"</span>: <span class="str">"npx"</span>,
      <span class="str">"args"</span>: [<span class="str">"strictdb-mcp"</span>],
      <span class="str">"env"</span>: {
        <span class="str">"STRICTDB_URI"</span>: <span class="str">"postgresql://user:pass@localhost:5432/mydb"</span>
      }
    }
  }
}</code></pre>

<h3>Claude Code Configuration</h3>
<pre><code>{
  <span class="str">"mcpServers"</span>: {
    <span class="str">"strictdb"</span>: {
      <span class="str">"type"</span>: <span class="str">"stdio"</span>,
      <span class="str">"command"</span>: <span class="str">"npx"</span>,
      <span class="str">"args"</span>: [<span class="str">"strictdb-mcp"</span>],
      <span class="str">"env"</span>: {
        <span class="str">"STRICTDB_URI"</span>: <span class="str">"postgresql://user:pass@localhost:5432/mydb"</span>
      }
    }
  }
}</code></pre>

<hr>

<!-- ============================================================ -->
<h2 id="events">Events</h2>
<pre><code>db.<span class="fn">on</span>(<span class="str">'connected'</span>, ({ backend, dbName, label }) => { ... });
db.<span class="fn">on</span>(<span class="str">'disconnected'</span>, ({ backend, reason, timestamp }) => { ... });
db.<span class="fn">on</span>(<span class="str">'reconnecting'</span>, ({ backend, attempt, maxAttempts, delayMs }) => { ... });
db.<span class="fn">on</span>(<span class="str">'reconnected'</span>, ({ backend, attempt, downtimeMs }) => { ... });
db.<span class="fn">on</span>(<span class="str">'error'</span>, ({ code, message, fix, backend }) => { ... });
db.<span class="fn">on</span>(<span class="str">'operation'</span>, ({ collection, operation, durationMs, receipt }) => { ... });
db.<span class="fn">on</span>(<span class="str">'slow-query'</span>, ({ collection, operation, durationMs, threshold }) => { ... });
db.<span class="fn">on</span>(<span class="str">'guardrail-blocked'</span>, ({ collection, operation, reason }) => { ... });
db.<span class="fn">on</span>(<span class="str">'pool-status'</span>, ({ active, idle, waiting, max }) => { ... });
db.<span class="fn">on</span>(<span class="str">'shutdown'</span>, ({ exitCode }) => { ... });</code></pre>

<!-- ============================================================ -->
<h2 id="reconnect">Reconnection</h2>
<p>Exponential backoff with jitter to prevent thundering herd:</p>
<pre><code><span class="cm">// Delay formula:</span>
<span class="cm">// baseDelay = initialDelayMs * (backoffMultiplier ^ (attempt - 1))</span>
<span class="cm">// cappedDelay = min(baseDelay, maxDelayMs)</span>
<span class="cm">// actualDelay = cappedDelay * (0.75 + random * 0.5)   ← jitter ±25%</span>

<span class="cm">// Example with defaults (1s initial, 2x multiplier, 30s max):</span>
<span class="cm">// Attempt 1: ~1s    (750ms – 1250ms)</span>
<span class="cm">// Attempt 2: ~2s    (1500ms – 2500ms)</span>
<span class="cm">// Attempt 3: ~4s    (3000ms – 5000ms)</span>
<span class="cm">// Attempt 4: ~8s    (6000ms – 10000ms)</span>
<span class="cm">// Attempt 5: ~16s   (12000ms – 20000ms)</span>
<span class="cm">// Attempt 6+: ~30s  (capped at maxDelayMs)</span></code></pre>

<!-- ============================================================ -->
<h2 id="timestamps">Auto Timestamps</h2>
<pre><code><span class="cm">// Enable with defaults (created_at, updated_at)</span>
<span class="kw">const</span> db = <span class="kw">await</span> <span class="type">StrictDB</span>.<span class="fn">create</span>({ uri, timestamps: <span class="num">true</span> });

<span class="cm">// Or customize field names</span>
<span class="kw">const</span> db = <span class="kw">await</span> <span class="type">StrictDB</span>.<span class="fn">create</span>({
  uri,
  timestamps: { createdAt: <span class="str">'born'</span>, updatedAt: <span class="str">'modified'</span> }
});</code></pre>
<ul>
  <li><strong>Insert:</strong> Both <code>createdAt</code> and <code>updatedAt</code> injected</li>
  <li><strong>Update:</strong> Only <code>updatedAt</code> injected (never overwrites <code>createdAt</code>)</li>
  <li><strong>User values preserved:</strong> If you explicitly set a timestamp field, StrictDB won't overwrite it</li>
  <li><strong>Immutable:</strong> Original documents are never mutated — new objects returned</li>
</ul>

<!-- ============================================================ -->
<h2 id="raw">Escape Hatch — <code>db.raw()</code></h2>
<p>Access the underlying native driver when you need backend-specific features:</p>
<pre><code><span class="kw">const</span> native = db.<span class="fn">raw</span>();

<span class="cm">// MongoDB → returns MongoClient</span>
<span class="cm">// PostgreSQL → returns pg.Pool</span>
<span class="cm">// MySQL → returns mysql2 connection</span>
<span class="cm">// MSSQL → returns mssql connection pool</span>
<span class="cm">// SQLite → returns better-sqlite3 Database</span>
<span class="cm">// Elasticsearch → returns @elastic/elasticsearch Client</span></code></pre>
<div class="callout callout-warn">
  <strong>Warning:</strong> Operations through <code>raw()</code> bypass guardrails, sanitization, receipts, and event logging. Use only when StrictDB's unified API doesn't cover your use case.
</div>

<hr>

<!-- ============================================================ -->
<h2 id="errors">Error Code Reference</h2>
<table>
  <thead><tr><th>Code</th><th>Retryable</th><th>.fix Message</th></tr></thead>
  <tbody>
    <tr><td><code>CONNECTION_FAILED</code></td><td><span class="badge badge-green">Yes</span></td><td>Check connection URI and ensure database server is running</td></tr>
    <tr><td><code>CONNECTION_LOST</code></td><td><span class="badge badge-green">Yes</span></td><td>Connection dropped — auto-reconnect will attempt recovery</td></tr>
    <tr><td><code>AUTHENTICATION_FAILED</code></td><td><span class="badge badge-red">No</span></td><td>Check username/password in connection URI</td></tr>
    <tr><td><code>TIMEOUT</code></td><td><span class="badge badge-green">Yes</span></td><td>Add a filter to narrow results, add an index, or increase timeout</td></tr>
    <tr><td><code>POOL_EXHAUSTED</code></td><td><span class="badge badge-green">Yes</span></td><td>Connection pool full — reduce concurrency or increase pool size</td></tr>
    <tr><td><code>DUPLICATE_KEY</code></td><td><span class="badge badge-red">No</span></td><td>Use updateOne() instead or check with queryOne() first</td></tr>
    <tr><td><code>VALIDATION_ERROR</code></td><td><span class="badge badge-red">No</span></td><td>Document doesn't match schema — see error details for field-specific fixes</td></tr>
    <tr><td><code>COLLECTION_NOT_FOUND</code></td><td><span class="badge badge-red">No</span></td><td>Did you mean "X"? Run ensureCollections() to create tables</td></tr>
    <tr><td><code>QUERY_ERROR</code></td><td><span class="badge badge-red">No</span></td><td>Check field names and filter operators</td></tr>
    <tr><td><code>GUARDRAIL_BLOCKED</code></td><td><span class="badge badge-red">No</span></td><td>Provide a non-empty filter or use confirm option</td></tr>
    <tr><td><code>UNKNOWN_OPERATOR</code></td><td><span class="badge badge-red">No</span></td><td>Use supported filter syntax: $eq, $ne, $gt, $gte, $lt, $lte, $in, $nin, $exists, $regex</td></tr>
    <tr><td><code>SCHEMA_MISMATCH</code></td><td><span class="badge badge-red">No</span></td><td>Document structure doesn't match registered schema</td></tr>
    <tr><td><code>UNSUPPORTED_OPERATION</code></td><td><span class="badge badge-red">No</span></td><td>Operation not available for this backend (e.g., transactions on Elasticsearch)</td></tr>
    <tr><td><code>INTERNAL_ERROR</code></td><td><span class="badge badge-red">No</span></td><td>Unexpected backend error — see originalError for details</td></tr>
  </tbody>
</table>

<!-- ============================================================ -->
<h2 id="types">TypeScript Types</h2>
<pre><code><span class="kw">import</span> <span class="kw">type</span> {
  <span class="type">Backend</span>,              <span class="cm">// 'mongo' | 'sql' | 'elastic'</span>
  <span class="type">Driver</span>,               <span class="cm">// 'mongodb' | 'pg' | 'mysql2' | 'mssql' | 'sqlite' | 'elasticsearch'</span>
  <span class="type">SqlDialect</span>,           <span class="cm">// 'pg' | 'mysql2' | 'mssql' | 'sqlite'</span>
  <span class="type">StrictFilter</span>,         <span class="cm">// MongoDB-style filter object</span>
  <span class="type">UpdateOperators</span>,      <span class="cm">// { $set?, $inc?, $unset?, $push?, $pull? }</span>
  <span class="type">QueryOptions</span>,         <span class="cm">// { sort?, limit?, skip?, projection? }</span>
  <span class="type">LookupOptions</span>,        <span class="cm">// { match, lookup, unwind?, sort?, limit? }</span>
  <span class="type">OperationReceipt</span>,     <span class="cm">// Write operation result</span>
  <span class="type">StrictDBConfig</span>,       <span class="cm">// create() configuration</span>
  <span class="type">StrictDBEvents</span>,       <span class="cm">// Typed event map</span>
  <span class="type">SanitizeRule</span>,         <span class="cm">// Custom sanitization rule</span>
  <span class="type">ReconnectConfig</span>,      <span class="cm">// Reconnection options</span>
  <span class="type">IndexDefinition</span>,      <span class="cm">// Index schema</span>
  <span class="type">CollectionSchema</span>,     <span class="cm">// Collection + Zod schema registration</span>
  <span class="type">StrictDBError</span>,        <span class="cm">// Error class with .fix, .code, .retryable</span>
} <span class="kw">from</span> <span class="str">'strictdb'</span>;</code></pre>

<h3>Using Generics</h3>
<pre><code><span class="kw">interface</span> <span class="type">User</span> {
  email: <span class="type">string</span>;
  name: <span class="type">string</span>;
  role: <span class="str">'admin'</span> | <span class="str">'user'</span> | <span class="str">'mod'</span>;
  age?: <span class="type">number</span>;
}

<span class="cm">// Fully typed — result is User | null</span>
<span class="kw">const</span> user = <span class="kw">await</span> db.<span class="fn">queryOne</span>&lt;<span class="type">User</span>&gt;(<span class="str">'users'</span>, { email: <span class="str">'alice@example.com'</span> });

<span class="cm">// Filter autocomplete works with the generic</span>
<span class="kw">const</span> admins = <span class="kw">await</span> db.<span class="fn">queryMany</span>&lt;<span class="type">User</span>&gt;(<span class="str">'users'</span>,
  { role: <span class="str">'admin'</span> },
  { sort: { name: <span class="num">1</span> }, limit: <span class="num">50</span> }
);</code></pre>

</main>
</div>

<script>
// Highlight current section in sidebar
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      document.querySelectorAll('.sidebar a').forEach(a => a.classList.remove('active'));
      const link = document.querySelector(`.sidebar a[href="#${entry.target.id}"]`);
      if (link) link.classList.add('active');
    }
  });
}, { rootMargin: '-80px 0px -70% 0px' });
document.querySelectorAll('h2[id], h3[id]').forEach(el => observer.observe(el));
</script>
</body>
</html>
